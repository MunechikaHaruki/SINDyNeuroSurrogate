#cython: language_level=3, boundscheck=False, wraparound=False, cdivision=True

from tqdm import tqdm
import h5py
import numpy as np
cimport numpy as np
import cython

# NumPy C-APIの初期化
np.import_array()

from libc.math cimport exp

cdef double a_m(double v):
    return 0.1 * (25 - v) / (exp((25 - v) / 10.0) - 1)


cdef b_m(double v):
    return 4.0 * exp(-v / 18.0)


cdef a_h(double v):
    return 0.07 * exp(-v / 20.0)


cdef b_h(double v):
    return 1.0 / (exp((30 - v) / 10.0) + 1)


cdef double a_n(double v):
    return 0.01 * (10 - v) / (exp((10 - v) / 10.0) - 1 + 0.001)  # ゼロ除算回避


cdef double b_n(double v):
    return 0.125 * np.exp(-v / 80.0)


cdef double derivative_x0(double x0,double x1,double u0):
    return {{derivative_x0}}

cdef double derivative_x1(double x0,double x1,double u0):
    return {{derivative_x1}}


cpdef np.ndarray[np.double_t, ndim=2] predict_cython(
    np.ndarray[np.double_t, ndim=1] init,
    double dt,
    int n_iter,
    np.ndarray[np.double_t, ndim=1] I_ext_in
):
    # Cレベルの変数を宣言 (cdef)
    cdef int nt, n_vars, i
    n_vars = init.shape[0]
    # 出力用のNumPy配列を準備
    cdef np.ndarray[np.double_t, ndim=2] x = np.zeros((n_iter, n_vars), dtype=np.double)
    x[0] = init

    # ループ内で使う変数を宣言
    cdef np.ndarray[np.double_t, ndim=1] derivative = np.empty(n_vars,dtype=np.double)

    # このループがC言語レベルで実行されるため高速になる
    with tqdm(total=n_iter - 1, desc="Predicting...") as pbar:
        for nt in range(n_iter - 1):
            # derivative = sindy_model.predict(x[nt].reshape(1, -1), u=I_ext_in[nt])[0]
            derivative[0]=derivative_x0(x[nt][0],x[nt][1],I_ext_in[nt])
            derivative[1]=derivative_x1(x[nt][0],x[nt][1],I_ext_in[nt])

            # オイラー法による更新 (配列要素へのアクセスも高速)
            for i in range(n_vars):
                x[nt + 1, i] = x[nt, i] + derivative[i] * dt
            pbar.update(1)
            
    return x

cpdef np.ndarray[np.double_t, ndim=2] predict_cython_threecomp(
    np.ndarray[np.double_t, ndim=1] init,
    double dt,
    int n_iter,
    np.ndarray[np.double_t, ndim=1] I_ext_in,
):
    # Cレベルの変数を宣言 (cdef)
    cdef n_vars = init.shape[0]
    # 出力用のNumPy配列を準備
    cdef np.ndarray[np.double_t, ndim=2] x = np.zeros((n_iter, n_vars), dtype=np.double)
    x[0] = init
    # ループ内で使う変数を宣言
    cdef double v_pre,v_soma,v_post,I_inj,I_pre,I_post
    cdef int nt, i
    with tqdm(total=n_iter - 1, desc="Predicting...") as pbar:
        for nt in range(n_iter - 1):
            v_soma=x[nt][0]
            v_pre=x[nt][2]
            v_post=x[nt][3]

            I_pre= {{G_12}}*(v_pre-v_soma)
            I_post = {{G_23}}*(v_soma-v_post)
            x[nt+1,0]=x[nt,0] + dt * derivative_x0(x[nt][0],x[nt][1],I_pre-I_post)
            x[nt+1,1]=x[nt,1] + dt * derivative_x1(x[nt][0],x[nt][1],I_pre-I_post)
            x[nt+1,2]=x[nt,2] + dt *  (-({{G_LEAK}})*(v_pre -({{E_LEAK}}))   -I_pre + I_ext_in[nt] )    /{{C}} * {{DT}}
            x[nt+1,3]=x[nt,3] + dt *  (-({{G_LEAK}})*(v_post-({{E_LEAK}}))   +I_post               )    /{{C}} * {{DT}}
            pbar.update(1)
    return x